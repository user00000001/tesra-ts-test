{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///external \"tesra-ts-crypto\"","webpack:///external \"long\"","webpack:///external \"cross-fetch\"","webpack:///external \"fs\"","webpack:///external \"crypto\"","webpack:///external \"bignumber.js\"","webpack:///./src/compiler/types.ts","webpack:///./src/compiler/csCompiler.ts","webpack:///./src/common/struct.ts","webpack:///./src/common/utils.ts","webpack:///./src/compiler/pyCompiler.ts","webpack:///./src/core/payload/deployCode.ts","webpack:///./src/common/uint256.ts","webpack:///./src/core/payload/invokeCode.ts","webpack:///./src/core/transaction.ts","webpack:///./src/network/rpcClient.ts","webpack:///./src/deployer.ts","webpack:///./src/invoker.ts","webpack:///./src/transactor.ts","webpack:///./src/wallet.ts","webpack:///./src/index.ts","webpack:///./src/compiler/index.ts"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","require","CompilerError","code","message","Error","url","this","payload","type","toString","method","body","JSON","stringify","headers","response","json","errcode","errdetail","avm","abi","startsWith","substring","lastIndexOf","replace","Buffer","hash","parse","Struct","items","sleep","ms","Promise","resolve","setTimeout","loadContract","path","loadCompiledContract","codeString","reverseBuffer","src","buffer","allocUnsafe","length","j","hex2num","str","bigIntFromBytes","toJSNumber","pushParam","parameter","builder","pushBool","writeOpCode","PUSH0","BOOLOR","pushNum","ADD","pushBytes","toArray","Map","pushMap","parameters","NEWSTRUCT","TOALTSTACK","reverse","forEach","DUPFROMALTSTACK","SWAP","APPEND","FROMALTSTACK","pushStruct","Array","isArray","PACK","pushArray","entries","NEWMAP","from","SETITEM","fromVmCode","debug","funcMap","undefined","funcmap","e","console","warn","options","needStorage","version","author","email","description","w","writeVarBytes","writeUint8","writeString","readVarBytes","readByte","readVarString","bf","serialize","getBytes","writeBytes","readBytes","b","u","Uint256","deserialize","InvokeCode","RawSig","invoke","verify","txType","nonce","toNumber","gasPrice","gasLimit","payer","sigs","parseFromBytes","sha256","serializeUnsigned","sig","push","addrs","getVerify","raw","serializeSigned","pstart","position","deserializeUnsigned","lenUnsigned","seek","rawUnsigned","sh","update","digest","readVarUInt","lenAll","writeUint32","writeUint64","writeVarUint","readUInt32","readUInt64","pl","getTxType","isZero","params","request","jsonrpc","id","req","then","address","makeRequest","toBase58","sendRequest","data","preExec","txHash","codeHash","asset","to","rpcAddress","client","getContract","result","processCallback","tx","sendRawTransaction","error","getSmartCodeEvent","buildInvokePayload","contract","APPCALL","getProgram","wait","info","payloadWriter","log","txWriter","sender","amount","amountBg","shiftedBy","tran","SYSCALL","loadWallet","walletPath","f","deserializeJson","createWallet","accounts","wallet","account","addAccount","createAccount","privateKey","password","bytes","decryptKey","publicKey","getPublicKey","sign","signature","invokationSript","verificationScript","addSig","signers","signatures","publicKeys","signer","initClient","createCompiler","compile","rest","deploy","setPayer","signTransaction","scriptHash","isDeployed","signTransactionMulti","transfer","withdrawTsg"],"mappings":"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","file":"index.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 6);\n","module.exports = require(\"tesra-ts-crypto\");","module.exports = require(\"long\");","module.exports = require(\"cross-fetch\");","module.exports = require(\"fs\");","module.exports = require(\"crypto\");","module.exports = require(\"bignumber.js\");","export type CompilerType = 'CSharp' | 'Python';\n\nexport interface CompilerOutput {\n  avm: Buffer;\n  abi: Buffer;\n  hash: string;\n  debug?: Debug;\n  funcMap?: FuncMap;\n}\n\nexport interface Debug {\n  avm: {\n    name: string;\n    hash: string;\n  };\n\n  compiler: {\n    name: string;\n    version: string;\n  };\n\n  files: Array<{ id: string; url: string }>;\n\n  map: Array<{ start: number; end: number; file: number; method: string; line: number; file_line_no: number }>;\n  breakpoints: any[];\n}\n\nexport interface FuncMap {\n  Functions: Array<{ Method: string; VarMap: { [key: string]: number } }>;\n}\n\nexport class CompilerError extends Error {\n  code: number;\n\n  constructor(code: number, message: string) {\n    super(message);\n    this.code = code;\n  }\n}\n\nexport interface Compiler {\n  compile(code: Buffer): Promise<CompilerOutput>;\n}\n","import fetch from 'cross-fetch';\nimport { Compiler, CompilerError, CompilerOutput } from './types';\n\n// tslint:disable:quotemark\nexport class CsCompiler implements Compiler {\n  url: string;\n  constructor(url: string = 'https://smartxcompiler.tesra.me/api/v1.0/csharp/compile') {\n    this.url = url;\n  }\n\n  async compile(code: Buffer): Promise<CompilerOutput> {\n    const payload = { type: 'CSharp', code: code.toString('utf-8') };\n\n    const response = await fetch(this.url, {\n      method: 'POST',\n      body: JSON.stringify(payload),\n      headers: {\n        'Content-Type': 'application/json'\n      }\n    });\n\n    const json = await response.json();\n    if (json.errcode !== 0) {\n      throw new CompilerError(json.errcode, json.errdetail);\n    }\n\n    let avm: string = json.avm;\n    let abi: string = json.abi;\n\n    if (avm.startsWith(\"b'\")) {\n      avm = avm.substring(2, avm.lastIndexOf(\"'\"));\n    }\n\n    if (abi.startsWith(\"b'\")) {\n      abi = abi.substring(2, abi.lastIndexOf(\"'\"));\n      abi = abi.replace(/\\\\n/g, '\\n');\n    }\n\n    return {\n      avm: new Buffer(avm, 'hex'),\n      abi: new Buffer(abi),\n      hash: JSON.parse(abi).hash\n    };\n  }\n}\n","export class Struct {\n  items: any[];\n\n  constructor(items: any[]) {\n    this.items = items;\n  }\n}\n","import { readFileSync } from 'fs';\nimport * as Long from 'long';\nimport { Address, OpCode, ProgramBuilder, Serialize } from 'tesra-ts-crypto';\nimport { Struct } from './struct';\n\nexport function sleep(ms: number) {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n}\n\nexport function loadContract(path: string) {\n  return readFileSync(path);\n}\n\nexport function loadCompiledContract(path: string) {\n  const codeBuffer = readFileSync(path);\n  const codeString = codeBuffer.toString();\n  return new Buffer(codeString, 'hex');\n}\n\nexport function loadOptionsFile(path: string) {\n  return readFileSync(path).toString();\n}\n\nexport function reverseBuffer(src: Buffer) {\n  const buffer = Buffer.allocUnsafe(src.length);\n\n  for (let i = 0, j = src.length - 1; i <= j; ++i, --j) {\n    buffer[i] = src[j];\n    buffer[j] = src[i];\n  }\n\n  return buffer;\n}\n\nexport function hex2num(str: string) {\n  const buffer = new Buffer(str, 'hex');\n  return Serialize.bigIntFromBytes(buffer).toJSNumber();\n}\n\nexport function pushParam(parameter: any, builder: ProgramBuilder) {\n  if (typeof parameter === 'boolean') {\n    builder.pushBool(parameter);\n    builder.writeOpCode(OpCode.PUSH0);\n    builder.writeOpCode(OpCode.BOOLOR);\n  } else if (typeof parameter === 'number') {\n    builder.pushNum(parameter);\n    builder.writeOpCode(OpCode.PUSH0);\n    builder.writeOpCode(OpCode.ADD);\n  } else if (parameter instanceof Long) {\n    builder.pushNum(parameter);\n    builder.writeOpCode(OpCode.PUSH0);\n    builder.writeOpCode(OpCode.ADD);\n  } else if (typeof parameter === 'string') {\n    builder.pushBytes(new Buffer(parameter));\n  } else if (parameter instanceof Buffer) {\n    builder.pushBytes(parameter);\n  } else if (parameter instanceof Address) {\n    builder.pushBytes(parameter.toArray());\n  } else if (parameter instanceof Map) {\n    pushMap(parameter, builder);\n  } else if (parameter instanceof Struct) {\n    pushStruct(parameter, builder);\n  } else if (Array.isArray(parameter)) {\n    pushArray(parameter, builder);\n  } else if (typeof parameter === 'object') {\n    // this is last, because other classes are also objects\n    pushMap(new Map(Object.entries(parameter)), builder);\n  } else {\n    throw new Error('Unsupported param type');\n  }\n}\n\nexport function pushArray(parameters: any[], builder: ProgramBuilder) {\n  parameters.reverse().forEach((parameter) => pushParam(parameter, builder));\n\n  builder.pushNum(parameters.length);\n  builder.writeOpCode(OpCode.PACK);\n}\n\nexport function pushStruct(parameters: Struct, builder: ProgramBuilder) {\n  builder.pushNum(0);\n  builder.writeOpCode(OpCode.NEWSTRUCT);\n  builder.writeOpCode(OpCode.TOALTSTACK);\n\n  parameters.items.reverse().forEach((parameter) => {\n    pushParam(parameter, builder);\n    builder.writeOpCode(OpCode.DUPFROMALTSTACK);\n    builder.writeOpCode(OpCode.SWAP);\n    builder.writeOpCode(OpCode.APPEND);\n  });\n\n  builder.writeOpCode(OpCode.FROMALTSTACK);\n}\n\nexport function pushMap(parameters: Map<any, any>, builder: ProgramBuilder) {\n  builder.writeOpCode(OpCode.NEWMAP);\n  builder.writeOpCode(OpCode.TOALTSTACK);\n\n  Array.from(parameters.entries())\n    .reverse()\n    .forEach(([key, value]) => {\n      builder.writeOpCode(OpCode.DUPFROMALTSTACK);\n      pushParam(key, builder);\n      pushParam(value, builder);\n      builder.writeOpCode(OpCode.SETITEM);\n    });\n\n  builder.writeOpCode(OpCode.FROMALTSTACK);\n}\n","import fetch from 'cross-fetch';\nimport { Address } from 'tesra-ts-crypto';\nimport { reverseBuffer } from '../common/utils';\nimport { Compiler, CompilerError, CompilerOutput, Debug, FuncMap } from './types';\n\nexport class PyCompiler implements Compiler {\n  url: string;\n\n  constructor(url: string = 'https://smartxcompiler.tesra.me/api/beta/python/compile') {\n    this.url = url;\n  }\n\n  async compile(code: Buffer): Promise<CompilerOutput> {\n    const payload = { type: 'Python', code: code.toString('utf-8') };\n\n    const response = await fetch(this.url, {\n      method: 'POST',\n      body: JSON.stringify(payload),\n      headers: {\n        'Content-Type': 'application/json'\n      }\n    });\n\n    const json = await response.json();\n\n    if (json.errcode !== 0) {\n      throw new CompilerError(json.errcode, json.errdetail);\n    }\n\n    let avm: string = json.avm;\n    const abi: string = json.abi;\n\n    // tslint:disable-next-line:quotemark\n    if (avm.startsWith(\"b'\")) {\n      // tslint:disable-next-line:quotemark\n      avm = avm.substring(2, avm.lastIndexOf(\"'\"));\n    }\n\n    const hash = reverseBuffer(Address.fromVmCode(new Buffer(avm, 'hex')).toArray()).toString('hex');\n\n    let debug: Debug | undefined;\n    let funcMap: FuncMap | undefined;\n\n    try {\n      if (json.debug !== undefined) {\n        debug = JSON.parse(json.debug);\n      }\n\n      if (json.funcmap !== undefined) {\n        funcMap = JSON.parse(json.funcmap);\n      }\n    } catch (e) {\n      // tslint:disable-next-line:no-console\n      console.warn('Failed to parse debug and funcmap from compiler');\n    }\n\n    return {\n      avm: new Buffer(avm, 'hex'),\n      abi: new Buffer(abi),\n      hash,\n      debug,\n      funcMap\n    };\n  }\n}\n","import { Reader, Writer } from 'tesra-ts-crypto';\n\nexport interface DeployCodeOptions {\n  code: Buffer;\n  needStorage: boolean;\n  name: string;\n  version: string;\n  author: string;\n  email: string;\n  description: string;\n}\n\nexport class DeployCode {\n  code: Buffer;\n  needStorage: boolean;\n  name: string;\n  version: string;\n  author: string;\n  email: string;\n  description: string;\n\n  constructor(\n    options: DeployCodeOptions = {\n      code: new Buffer(''),\n      needStorage: false,\n      name: '',\n      version: '',\n      author: '',\n      email: '',\n      description: ''\n    }\n  ) {\n    this.code = options.code;\n    this.needStorage = options.needStorage;\n    this.name = options.name;\n    this.version = options.version;\n    this.author = options.author;\n    this.email = options.email;\n    this.description = options.description;\n  }\n\n  serialize(w: Writer) {\n    w.writeVarBytes(this.code);\n    w.writeUint8(this.needStorage ? 1 : 0);\n    w.writeString(this.name);\n    w.writeString(this.version);\n    w.writeString(this.author);\n    w.writeString(this.email);\n    w.writeString(this.description);\n  }\n\n  deserialize(r: Reader) {\n    this.code = r.readVarBytes();\n    this.needStorage = r.readByte() === 1 ? true : false;\n    this.name = r.readVarString();\n    this.version = r.readVarString();\n    this.author = r.readVarString();\n    this.email = r.readVarString();\n    this.description = r.readVarString();\n  }\n\n  toArray(): Buffer {\n    const bf = new Writer();\n    this.serialize(bf);\n    return new Buffer(bf.getBytes());\n  }\n\n  getCode() {\n    return this.code;\n  }\n}\n\nexport function isDeployCode(item: any): item is DeployCode {\n  return item instanceof DeployCode;\n}\n","import { Reader, Writer } from 'tesra-ts-crypto';\n\nconst UINT256_SIZE = 32;\n\nexport class Uint256 {\n  static parseFromBytes(b: Buffer): Uint256 {\n    const r = new Reader(b);\n    const u = new Uint256();\n    u.deserialize(r);\n\n    return u;\n  }\n  private value: Buffer;\n\n  toArray(): Buffer {\n    const bf = new Writer();\n    this.serialize(bf);\n    return new Buffer(bf.getBytes());\n  }\n\n  serialize(w: Writer) {\n    w.writeBytes(this.value);\n  }\n\n  deserialize(r: Reader) {\n    try {\n      this.value = r.readBytes(UINT256_SIZE);\n    } catch (e) {\n      throw new Error('deserialize Uint256 error');\n    }\n  }\n}\n","import { Reader, Writer } from 'tesra-ts-crypto';\n\nexport class InvokeCode {\n  private code: Buffer;\n\n  constructor(code: Buffer = new Buffer('')) {\n    this.code = code;\n  }\n\n  serialize(w: Writer) {\n    try {\n      w.writeVarBytes(this.code);\n    } catch (e) {\n      throw new Error(`InvokeCode Code Serialize failed: ${e}`);\n    }\n  }\n\n  deserialize(r: Reader) {\n    try {\n      const code = r.readVarBytes();\n\n      this.code = code;\n    } catch (e) {\n      throw new Error(`InvokeCode Code Deserialize failed: ${e}`);\n    }\n  }\n}\n","import { createHash, randomBytes } from 'crypto';\nimport * as Long from 'long';\nimport { Address, Hash, Reader, Writer } from 'tesra-ts-crypto';\nimport { Uint256 } from '../common/uint256';\nimport { DeployCode } from './payload/deployCode';\nimport { InvokeCode } from './payload/invokeCode';\n\nexport const TX_MAX_SIG_SIZE = 16;\nexport type TransactionType = number;\n\nexport const Bookkeeper = 0x02;\nexport const Deploy = 0xd0;\nexport const Invoke = 0xd1;\n\n/**\n * Payload define the func for loading the payload data\n * base on payload type which have different struture\n */\nexport interface Payload {\n  /**\n   * Serialize payload data\n   */\n  serialize(w: Writer): void;\n\n  deserialize(r: Reader): void;\n}\n\nexport class RawSig {\n  static deserialize(r: Reader): RawSig {\n    const invoke = r.readVarBytes();\n    const verify = r.readVarBytes();\n\n    return new RawSig(invoke, verify);\n  }\n  private invoke: Buffer;\n  private verify: Buffer;\n\n  constructor(invoke: Buffer, verify: Buffer) {\n    this.invoke = invoke;\n    this.verify = verify;\n  }\n\n  getVerify() {\n    return this.verify;\n  }\n\n  serialize(w: Writer) {\n    w.writeVarBytes(this.invoke);\n    w.writeVarBytes(this.verify);\n  }\n}\n\nexport interface TransactionOptions {\n  version?: number;\n  txType?: TransactionType;\n  nonce?: number;\n  gasPrice?: Long;\n  gasLimit?: Long;\n  payer?: Address;\n  payload?: Payload;\n  sigs?: RawSig[];\n}\n\nexport class Transaction {\n  private version: number;\n  private txType: TransactionType;\n  private nonce: number;\n  private gasPrice: Long;\n  private gasLimit: Long;\n  private payer: Address;\n  private payload: Payload;\n\n  private sigs: RawSig[];\n\n  private raw: Buffer | undefined; // raw transaction data\n\n  private hash: Uint256;\n\n  constructor({\n    version = 0,\n    txType = Invoke,\n    nonce = Long.fromBytes([...randomBytes(4)], true, true).toNumber(),\n    gasPrice = Long.fromNumber(500),\n    gasLimit = Long.fromNumber(30000),\n    payer = new Address('0000000000000000000000000000000000000000'),\n    payload = new InvokeCode(),\n    sigs = []\n  }: TransactionOptions = {}) {\n    this.version = version;\n    this.txType = txType;\n    this.nonce = nonce;\n    this.gasPrice = gasPrice;\n    this.gasLimit = gasLimit;\n    this.payer = payer;\n    this.payload = payload;\n    this.sigs = sigs;\n\n    this.hash = Uint256.parseFromBytes(Hash.sha256(this.serializeUnsigned()));\n  }\n\n  getVersion() {\n    return this.version;\n  }\n\n  getNonce() {\n    return this.nonce;\n  }\n\n  getGasPrice(): Long {\n    return this.gasPrice;\n  }\n\n  getGasLimit(): Long {\n    return this.gasLimit;\n  }\n  getHash() {\n    return this.hash;\n  }\n\n  getTxType() {\n    return this.txType;\n  }\n\n  getPayer() {\n    return this.payer;\n  }\n\n  setPayer(payer: Address) {\n    this.payer = payer;\n  }\n\n  getPayload() {\n    return this.payload;\n  }\n\n  addSig(sig: RawSig) {\n    this.sigs.push(sig);\n  }\n\n  getSignatureAddresses(): Address[] {\n    const addrs: Address[] = [];\n\n    for (const sig of this.sigs) {\n      addrs.push(Address.fromVmCode(sig.getVerify()));\n    }\n\n    return addrs;\n  }\n\n  serialize(w: Writer) {\n    if (this.raw !== undefined) {\n      if (this.raw.length === 0) {\n        throw new Error('wrong constructed transaction');\n      }\n\n      w.writeBytes(this.raw);\n    } else {\n      w.writeBytes(this.serializeUnsigned());\n      w.writeBytes(this.serializeSigned());\n    }\n  }\n\n  deserialize(r: Reader) {\n    const pstart = r.position();\n    this.deserializeUnsigned(r);\n    const pos = r.position();\n    const lenUnsigned = pos - pstart;\n    r.seek(-lenUnsigned, 'relative');\n    const rawUnsigned = r.readBytes(lenUnsigned);\n\n    const sh = createHash('sha256');\n    sh.update(rawUnsigned);\n    this.hash = Uint256.parseFromBytes(sh.digest());\n\n    // tx sigs\n    const length = r.readVarUInt().toNumber();\n\n    if (length > TX_MAX_SIG_SIZE) {\n      throw new Error(`transaction signature number ${length} execced ${TX_MAX_SIG_SIZE}`);\n    }\n\n    for (let i = 0; i < length; i++) {\n      const sig = RawSig.deserialize(r);\n      this.sigs.push(sig);\n    }\n\n    const pend = r.position();\n    const lenAll = pend - pstart;\n    r.seek(-lenAll, 'relative');\n    this.raw = r.readBytes(lenAll);\n  }\n\n  toArray(): Buffer {\n    const bf = new Writer();\n    this.serialize(bf);\n    return new Buffer(bf.getBytes());\n  }\n\n  /**\n   * Serialize transaction data exclueds signatures\n   */\n  serializeUnsigned() {\n    const w = new Writer();\n    w.writeUint8(this.version);\n    w.writeUint8(this.txType);\n    w.writeUint32(this.nonce);\n    w.writeUint64(this.gasPrice);\n    w.writeUint64(this.gasLimit);\n    this.payer.serialize(w);\n    this.payload.serialize(w);\n    w.writeVarUint(0);\n\n    return w.getBytes();\n  }\n\n  private deserializeUnsigned(r: Reader) {\n    this.version = r.readByte();\n    this.txType = r.readByte();\n    this.nonce = r.readUInt32();\n    this.gasPrice = r.readUInt64();\n    this.gasLimit = r.readUInt64();\n    this.payer = Address.deserialize(r.readBytes(20));\n\n    if (this.txType === Invoke) {\n      const pl = new InvokeCode();\n      pl.deserialize(r);\n      this.payload = pl;\n    } else if (this.txType === Deploy) {\n      const pl = new DeployCode();\n      pl.deserialize(r);\n      this.payload = pl;\n    } else {\n      throw new Error(`unsupported tx type ${this.getTxType()}`);\n    }\n\n    const length = r.readVarUInt();\n\n    if (!length.isZero()) {\n      throw new Error('transaction attribute must be 0, got %d');\n    }\n  }\n\n  private serializeSigned() {\n    const w = new Writer();\n    w.writeVarUint(this.sigs.length);\n\n    // tslint:disable-next-line:prefer-for-of\n    for (let i = 0; i < this.sigs.length; i++) {\n      this.sigs[i].serialize(w);\n    }\n\n    return w.getBytes();\n  }\n}\n","/*\n * Copyright (C) 2019-2020 The TesraSupernet Authors\n * This file is part of The TesraSupernet library.\n *\n * The TesraSupernet is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * The TesraSupernet is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with The TesraSupernet.  If not, see <http://www.gnu.org/licenses/>.\n */\n\nimport fetch from 'cross-fetch';\nimport { Address } from 'tesra-ts-crypto';\n\n/**\n * Wrapper class for RPC apis.\n */\nexport class RpcClient {\n  /**\n   * Url of the blockchain node\n   */\n  url: string;\n\n  constructor(url: string = 'http://dapp2.tesra.me:25768') {\n    this.url = url;\n  }\n\n  /**\n   * Get the current blockchain node url.\n   */\n  getUrl() {\n    return this.url;\n  }\n\n  /**\n   * Make request base on method and parameters\n   * @param method Method's name\n   * @param params Parameters\n   */\n  makeRequest(method: string, ...params: any[]) {\n    const request = {\n      jsonrpc: '2.0',\n      method,\n      params,\n      id: 1\n    };\n\n    return request;\n  }\n\n  sendRequest(req: any) {\n    return fetch(this.url, {\n      method: 'POST',\n      body: JSON.stringify(req),\n      headers: {\n        'Content-Type': 'application/json'\n      }\n    }).then((response) => response.json());\n  }\n\n  /**\n   * Get the balance of some address.\n   * The result contains TST and TSG.\n   * @param address Address\n   */\n  getBalance(address: Address): Promise<any> {\n    const req = this.makeRequest('getbalance', address.toBase58());\n    return this.sendRequest(req);\n  }\n\n  /**\n   * Get the unbound TSG of some address.\n   * The result contains TSG.\n   * @param address Address\n   */\n  getUnboundTsg(address: Address): Promise<any> {\n    const req = this.makeRequest('getunboundtsg', address.toBase58());\n    return this.sendRequest(req);\n  }\n\n  /**\n   * Send ran transaction to blockchain.\n   * @param data Hex encoded data.\n   * @param preExec Decides if it is a pre-execute transaction.\n   */\n  sendRawTransaction(data: string | Buffer, preExec: boolean = false): Promise<any> {\n    let req;\n\n    if (data instanceof Buffer) {\n      data = data.toString('hex');\n    }\n\n    if (preExec) {\n      req = this.makeRequest('sendrawtransaction', data, 1);\n    } else {\n      req = this.makeRequest('sendrawtransaction', data);\n    }\n\n    return this.sendRequest(req);\n  }\n\n  /**\n   * Get raw transaction by transaction hash.\n   * The result is hex encoded string.\n   * @param txHash Reversed transaction hash\n   */\n  getRawTransaction(txHash: string): Promise<any> {\n    const req = this.makeRequest('getrawtransaction', txHash);\n    return this.sendRequest(req);\n  }\n\n  /**\n   * Get transaction info by transaction hash.\n   * The result is json.\n   * @param txHash Reversed transaction hash.\n   */\n  getRawTransactionJson(txHash: string): Promise<any> {\n    const req = this.makeRequest('getrawtransaction', txHash, 1);\n    return this.sendRequest(req);\n  }\n\n  /**\n   * Get the nodes count.\n   */\n  getNodeCount(): Promise<any> {\n    const req = this.makeRequest('getconnectioncount');\n    return this.sendRequest(req);\n  }\n\n  /**\n   * Get the current block height.\n   */\n  getBlockHeight(): Promise<any> {\n    const req = this.makeRequest('getblockcount');\n    return this.sendRequest(req);\n  }\n\n  /**\n   * Get the all blocks count.\n   */\n  getBlockCount(): Promise<any> {\n    const req = this.makeRequest('getblockcount');\n    return this.sendRequest(req);\n  }\n\n  /**\n   * Get block info by block's height or hash.\n   * The result is json.\n   * @param value Block's hash or height\n   */\n  getBlockJson(value: string | number): Promise<any> {\n    const req = this.makeRequest('getblock', value, 1);\n    return this.sendRequest(req);\n  }\n\n  /**\n   * Get contract info by contract' code hash.\n   * The result is hex encoded string.\n   * @param hash Contract's code hash.\n   */\n  getContract(hash: string): Promise<any> {\n    const req = this.makeRequest('getcontractstate', hash);\n    return this.sendRequest(req);\n  }\n\n  /**\n   * Get contract info by contract's code hash.\n   * The result is json.\n   * @param codeHash Contract's code hash.\n   */\n  getContractJson(codeHash: string): Promise<any> {\n    const req = this.makeRequest('getcontractstate', codeHash, 1);\n    return this.sendRequest(req);\n  }\n\n  /**\n   * Get block info by block's height or hash.\n   * The result is hex encoded string.\n   *\n   * @param value Block's height or hash\n   */\n  getBlock(value: string | number): Promise<any> {\n    const req = this.makeRequest('getblock', value);\n    return this.sendRequest(req);\n  }\n\n  /**\n   * Get smart contract event.\n   * If parameter is transaction's hash, the result is the event of that transaction.\n   * If parameter is block's height, the result is all the events of that block.\n   *\n   * @param value Transaction's hash or block's height\n   */\n  getSmartCodeEvent(value: string | number): Promise<any> {\n    const req = this.makeRequest('getsmartcodeevent', value);\n    return this.sendRequest(req);\n  }\n\n  /**\n   * Get block height by transaction hash\n   * @param txHash Reversed transaction hash\n   */\n  getBlockHeightByTxHash(txHash: string): Promise<any> {\n    const req = this.makeRequest('getblockheightbytxhash', txHash);\n    return this.sendRequest(req);\n  }\n\n  /**\n   * Get stored value in smart contract by contract's code hash and the key.\n   * @param codeHash Contract's code hash\n   * @param key Key of stored value\n   */\n  getStorage(codeHash: string, key: string): Promise<any> {\n    const req = this.makeRequest('getstorage', codeHash, key);\n    return this.sendRequest(req);\n  }\n\n  /**\n   * Get merkle proof by transaction hash.\n   * @param hash Reversed transaction hash\n   */\n  getMerkleProof(hash: string): Promise<any> {\n    const req = this.makeRequest('getmerkleproof', hash);\n    return this.sendRequest(req);\n  }\n\n  /**\n   * Get allowanece\n   * @param asset Asset's type. Only TST and TSG supported.\n   * @param from Address of allowance's sender.\n   * @param to Address of allowance's receiver.\n   */\n  getAllowance(asset: string, from: Address, to: Address): Promise<any> {\n    const req = this.makeRequest('getallowance', asset, from.toBase58(), to.toBase58());\n    return this.sendRequest(req);\n  }\n}\n","import * as Long from 'long';\nimport { Address, Writer } from 'tesra-ts-crypto';\nimport { sleep } from './common/utils';\nimport { DeployCode } from './core/payload/deployCode';\nimport { Deploy, Transaction } from './core/transaction';\nimport { RpcClient } from './network/rpcClient';\n\nexport interface Deployment {\n  code: Buffer;\n  needStorage?: boolean;\n  name?: string;\n  version?: string;\n  author?: string;\n  email?: string;\n  description?: string;\n}\n\nexport interface DeployerOptions extends Deployment {\n  gasLimit?: string;\n  gasPrice?: string;\n\n  processCallback?: (transaction: Transaction) => Promise<void> | void;\n}\n\nexport class Deployer {\n  rpcAddress: string;\n\n  constructor(rpcAddress: string) {\n    this.rpcAddress = rpcAddress;\n  }\n\n  async isDeployed(address: Address) {\n    const client = new RpcClient(this.rpcAddress);\n\n    const response = await client.getContract(address.toArray().toString('hex'));\n    if (response.result === 'unknow contract' || response.result === 'unknow contracts') {\n      return false;\n    } else {\n      return true;\n    }\n  }\n\n  async deploy({\n    code,\n    needStorage = false,\n    name = '',\n    version = '',\n    author = '',\n    email = '',\n    description = '',\n    gasPrice = '500',\n    gasLimit = '20000000',\n    processCallback\n  }: DeployerOptions) {\n    const payload = new DeployCode({\n      code,\n      needStorage,\n      name,\n      version,\n      author,\n      email,\n      description\n    });\n\n    const tx = new Transaction({\n      txType: Deploy,\n      payload,\n      gasPrice: Long.fromString(gasPrice),\n      gasLimit: Long.fromString(gasLimit)\n    });\n\n    if (processCallback !== undefined) {\n      const result = processCallback(tx);\n      if (result instanceof Promise) {\n        await result;\n      }\n    }\n\n    const client = new RpcClient(this.rpcAddress);\n\n    const w = new Writer();\n    tx.serialize(w);\n\n    const response = await client.sendRawTransaction(w.getBytes(), false);\n\n    if (response.error !== 0) {\n      throw new Error(`Failed to deploy contract: ${response.error} - ${response.result}`);\n    }\n\n    await sleep(3000);\n    return await client.getSmartCodeEvent(response.result);\n  }\n}\n","import * as Long from 'long';\nimport { OpCode, ProgramBuilder, Writer } from 'tesra-ts-crypto';\nimport { pushParam, reverseBuffer, sleep } from './common/utils';\nimport { InvokeCode } from './core/payload/invokeCode';\nimport { Invoke as InvokeEnum, Transaction } from './core/transaction';\nimport { RpcClient } from './network/rpcClient';\n\n// tslint:disable:no-console\n\nexport interface Invoke {\n  contract: string;\n  method: string;\n  parameters?: any[];\n}\n\nexport interface InvokerOptions extends Invoke {\n  gasLimit?: string;\n  gasPrice?: string;\n  preExec?: boolean;\n  wait?: boolean;\n  debug?: boolean;\n\n  processCallback?: (transaction: Transaction) => Promise<void> | void;\n}\n\nexport function buildInvokePayload(contract: string, method: string, parameters: any[]) {\n  const builder: ProgramBuilder = new ProgramBuilder();\n\n  parameters = [method, parameters];\n\n  parameters.reverse().forEach((parameter) => pushParam(parameter, builder));\n\n  builder.writeOpCode(OpCode.APPCALL);\n  builder.writeBytes(reverseBuffer(new Buffer(contract, 'hex')));\n\n  const code = builder.getProgram();\n  return code;\n}\n\nexport class Invoker {\n  rpcAddress: string;\n\n  constructor(rpcAddress: string) {\n    this.rpcAddress = rpcAddress;\n  }\n\n  async invoke({\n    method,\n    parameters = [],\n    contract,\n    gasPrice = '500',\n    gasLimit = '20000000',\n    preExec,\n    processCallback,\n    wait = true,\n    debug = false\n  }: InvokerOptions) {\n    if (debug) {\n      console.info(`Preparing smart contract call ${method}...`);\n    }\n\n    const payload = new InvokeCode(buildInvokePayload(contract, method, parameters));\n\n    if (debug) {\n      const payloadWriter = new Writer();\n      payload.serialize(payloadWriter);\n      console.log(`Payload is: ${payloadWriter.getBytes().toString('hex')}`);\n    }\n\n    const tx = new Transaction({\n      txType: InvokeEnum,\n      payload,\n      gasPrice: Long.fromString(gasPrice),\n      gasLimit: Long.fromString(gasLimit)\n    });\n\n    if (debug) {\n      const txWriter = new Writer();\n      tx.serialize(txWriter);\n      console.log(`Unsigned TX is: ${txWriter.getBytes().toString('hex')}`);\n    }\n\n    if (processCallback !== undefined) {\n      const result = processCallback(tx);\n      if (result instanceof Promise) {\n        await result;\n      }\n    }\n\n    const client = new RpcClient(this.rpcAddress);\n\n    const w = new Writer();\n    tx.serialize(w);\n\n    const response = await client.sendRawTransaction(w.getBytes(), preExec);\n\n    if (response.error !== 0) {\n      throw new Error('Failed to invoke contract: ' + response.result);\n    }\n\n    if (preExec || !wait) {\n      return response;\n    }\n\n    await sleep(3000);\n    return await client.getSmartCodeEvent(response.result);\n  }\n}\n","import BigNumber from 'bignumber.js';\nimport * as Long from 'long';\nimport { Address, OpCode, ProgramBuilder, Writer } from 'tesra-ts-crypto';\nimport { Struct } from './common/struct';\nimport { pushParam, sleep } from './common/utils';\nimport { InvokeCode } from './core/payload/invokeCode';\nimport { Invoke, Transaction } from './core/transaction';\nimport { RpcClient } from './network/rpcClient';\n\nexport interface Transfer {\n  sender: Address;\n  to: Address;\n  amount: string;\n  asset: string;\n}\n\nexport interface TransactorTransferOptions extends Transfer {\n  gasLimit?: string;\n  gasPrice?: string;\n\n  wait?: boolean;\n\n  processCallback?: (transaction: Transaction) => Promise<void> | void;\n}\n\nexport class Transactor {\n  rpcAddress: string;\n\n  constructor(rpcAddress: string) {\n    this.rpcAddress = rpcAddress;\n  }\n\n  async transfer({\n    sender,\n    to,\n    amount,\n    asset,\n    gasPrice = '500',\n    gasLimit = '20000000',\n    processCallback,\n    wait = true\n  }: TransactorTransferOptions) {\n    let amountBg = new BigNumber(amount);\n    if (asset === 'tsg') {\n      amountBg = amountBg.shiftedBy(9);\n    }\n\n    const builder: ProgramBuilder = new ProgramBuilder();\n\n    const tran = new Struct([sender, to, Long.fromString(amountBg.toString())].reverse());\n    const parameters = [0, new Address(this.getContract(asset)), 'transfer', [tran]];\n\n    parameters.reverse().forEach((parameter) => pushParam(parameter, builder));\n    builder.writeOpCode(OpCode.SYSCALL);\n    builder.pushBytes(new Buffer('Tesra.Native.Invoke'));\n\n    const code = builder.getProgram();\n    const payload = new InvokeCode(code);\n\n    const tx = new Transaction({\n      txType: Invoke,\n      payload,\n      gasPrice: Long.fromString(gasPrice),\n      gasLimit: Long.fromString(gasLimit)\n    });\n\n    if (processCallback !== undefined) {\n      const result = processCallback(tx);\n      if (result instanceof Promise) {\n        await result;\n      }\n    }\n\n    const client = new RpcClient(this.rpcAddress);\n    const w = new Writer();\n    tx.serialize(w);\n\n    const response = await client.sendRawTransaction(w.getBytes(), false);\n\n    if (response.error !== 0) {\n      throw new Error(`Failed to make the transfer: ${response.error} - ${response.result}`);\n    }\n\n    if (!wait) {\n      return response;\n    }\n\n    await sleep(3000);\n    return await client.getSmartCodeEvent(response.result);\n  }\n\n  async withdrawTsg({\n    sender,\n    to,\n    amount,\n    gasPrice = '500',\n    gasLimit = '20000000',\n    processCallback,\n    wait = true\n  }: TransactorTransferOptions) {\n    const amountBg = new BigNumber(amount).shiftedBy(9);\n\n    const builder: ProgramBuilder = new ProgramBuilder();\n\n    const tran = new Struct(\n      [sender, new Address(this.getContract('tst')), to, Long.fromString(amountBg.toString())].reverse()\n    );\n    const parameters = [0, new Address(this.getContract('tsg')), 'transferFrom', tran];\n\n    parameters.reverse().forEach((parameter) => pushParam(parameter, builder));\n    builder.writeOpCode(OpCode.SYSCALL);\n    builder.pushBytes(new Buffer('Tesra.Native.Invoke'));\n\n    const code = builder.getProgram();\n    const payload = new InvokeCode(code);\n\n    const tx = new Transaction({\n      txType: Invoke,\n      payload,\n      gasPrice: Long.fromString(gasPrice),\n      gasLimit: Long.fromString(gasLimit)\n    });\n\n    if (processCallback !== undefined) {\n      const result = processCallback(tx);\n      if (result instanceof Promise) {\n        await result;\n      }\n    }\n\n    const client = new RpcClient(this.rpcAddress);\n    const w = new Writer();\n    tx.serialize(w);\n\n    const response = await client.sendRawTransaction(w.getBytes(), false);\n\n    if (response.error !== 0) {\n      throw new Error(`Failed to make the withdraw Tsg: ${response.error} - ${response.result}`);\n    }\n\n    if (!wait) {\n      return response;\n    }\n\n    await sleep(3000);\n    return await client.getSmartCodeEvent(response.result);\n  }\n\n  private getContract(asset: string) {\n    if (asset === 'tst') {\n      return '0000000000000000000000000000000000000001';\n    } else if (asset === 'tsg') {\n      return '0000000000000000000000000000000000000002';\n    } else {\n      throw new Error(`Invalid asset: ${asset}.`);\n    }\n  }\n}\n","import { randomBytes } from 'crypto';\nimport * as fs from 'fs';\nimport {\n  Account,\n  Hash,\n  PrivateKey,\n  programFromMultiPubKeys,\n  programFromParams,\n  programFromPubKey,\n  PublicKey,\n  Wallet\n} from 'tesra-ts-crypto';\nimport { RawSig, Transaction } from './core/transaction';\nimport { Signer } from './types';\n\nexport function loadWallet(walletPath: string): Wallet {\n  const f = fs.readFileSync(walletPath, 'utf8');\n  return Wallet.deserializeJson(f);\n}\n\nexport function createWallet(accounts: Account[]): Wallet {\n  const wallet = Wallet.create();\n\n  accounts.forEach((account) => wallet.addAccount(account));\n  return wallet;\n}\n\nexport function createAccount(privateKey: string): Account {\n  return Account.create(randomBytes(4).toString('hex'), PrivateKey.deserialize(new Buffer(privateKey, 'hex')), '');\n}\n\nexport async function signTransaction(tx: Transaction, account: Account, password: string) {\n  const bytes = tx.serializeUnsigned();\n  const hash = Hash.sha256(Hash.sha256(bytes));\n\n  const privateKey = await account.decryptKey(password);\n  const publicKey = privateKey.getPublicKey();\n  const signature = await privateKey.sign(hash);\n\n  const invokationSript = programFromParams([signature.serialize()]);\n  const verificationScript = programFromPubKey(publicKey);\n\n  const sig = new RawSig(invokationSript, verificationScript);\n  tx.addSig(sig);\n}\n\nexport async function signTransactionMulti(tx: Transaction, m: number, signers: Signer[]) {\n  const bytes = tx.serializeUnsigned();\n  const hash = Hash.sha256(Hash.sha256(bytes));\n  const signatures: Buffer[] = [];\n  const publicKeys: PublicKey[] = [];\n\n  for (const signer of signers) {\n    const privateKey = await signer.account.decryptKey(signer.password);\n    const publicKey = privateKey.getPublicKey();\n    const signature = await privateKey.sign(hash);\n\n    publicKeys.push(publicKey);\n    signatures.push(signature.serialize());\n  }\n\n  const invokationSript = programFromParams(signatures);\n  const verificationScript = programFromMultiPubKeys(m, publicKeys);\n\n  const sig = new RawSig(invokationSript, verificationScript);\n  tx.addSig(sig);\n}\n","import { Address } from 'tesra-ts-crypto';\nimport { CompilerOutput, createCompiler } from './compiler';\nimport { Deployer } from './deployer';\nimport { Invoker } from './invoker';\nimport { Transactor } from './transactor';\nimport {\n  Client,\n  CompileOptions,\n  DeployOptions,\n  InitClientOptions,\n  InvokeOptions,\n  IsDeployedOptions,\n  TransferOptions\n} from './types';\nimport { signTransaction, signTransactionMulti } from './wallet';\n\nexport function initClient({ rpcAddress = 'http://dapp2.tesra.me:25768' }: InitClientOptions): Client {\n  return {\n    rpcAddress\n  };\n}\n\nexport function compile({ code, type, url }: CompileOptions): Promise<CompilerOutput> {\n  const compiler = createCompiler({ type, url });\n  return compiler.compile(code);\n}\n\nexport function deploy({ client, account, password, ...rest }: DeployOptions) {\n  const deployer = new Deployer(client.rpcAddress);\n  return deployer.deploy({\n    ...rest,\n    processCallback: async (tx) => {\n      tx.setPayer(account.address);\n      await signTransaction(tx, account, password !== undefined ? password : '');\n    }\n  });\n}\n\nexport function isDeployed({ client, scriptHash }: IsDeployedOptions) {\n  const deployer = new Deployer(client.rpcAddress);\n  return deployer.isDeployed(new Address(scriptHash));\n}\n\nexport function invoke({ client, account, password, signers, ...rest }: InvokeOptions) {\n  const invoker = new Invoker(client.rpcAddress);\n  return invoker.invoke({\n    ...rest,\n    processCallback: async (tx) => {\n      if (account !== undefined) {\n        tx.setPayer(account.address);\n        await signTransaction(tx, account, password !== undefined ? password : '');\n      }\n\n      if (signers !== undefined) {\n        await signTransactionMulti(tx, signers.length, signers);\n      }\n    }\n  });\n}\n\nexport function transfer({ client, account, password, ...rest }: TransferOptions) {\n  const transactor = new Transactor(client.rpcAddress);\n  return transactor.transfer({\n    ...rest,\n    processCallback: async (tx) => {\n      if (account !== undefined) {\n        tx.setPayer(account.address);\n        await signTransaction(tx, account, password !== undefined ? password : '');\n      }\n    }\n  });\n}\n\nexport function withdrawTsg({ client, account, password, ...rest }: TransferOptions) {\n  const transactor = new Transactor(client.rpcAddress);\n  return transactor.withdrawTsg({\n    ...rest,\n    processCallback: async (tx) => {\n      if (account !== undefined) {\n        tx.setPayer(account.address);\n        await signTransaction(tx, account, password !== undefined ? password : '');\n      }\n    }\n  });\n}\n\nexport { CompilerType, CompilerOutput } from './compiler';\nexport { loadContract, loadCompiledContract } from './common/utils';\nexport { loadWallet, createWallet, createAccount } from './wallet';\nexport { hex2num, reverseBuffer } from './common/utils';\nexport { RpcClient } from './network/rpcClient';\nexport { buildInvokePayload } from './invoker';\nexport { InvokeCode } from './core/payload/invokeCode';\nexport { DeployCode } from './core/payload/deployCode';\nexport { Transaction } from './core/transaction';\nexport { Signer } from './types';\n","import { CsCompiler } from './csCompiler';\nimport { PyCompiler } from './pyCompiler';\nimport { CompilerType } from './types';\n\nexport interface CreateCompilerOptions {\n  type: CompilerType;\n  url?: string;\n}\n\nexport function createCompiler({ type, url }: CreateCompilerOptions) {\n  switch (type) {\n    case 'Python':\n      return new PyCompiler(url);\n    case 'CSharp':\n      return new CsCompiler(url);\n    default:\n      throw new Error('Unsupported compiler');\n  }\n}\n\nexport * from './types';\n"],"sourceRoot":""}